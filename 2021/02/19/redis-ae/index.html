<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基于 Redis 6.0.10 通过这篇文章想说明几个问题:  高性能服务器的组成 I&#x2F;O 多路复用的使用 redis 定时器的实现">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 源码学习 - ae 服务器模块">
<meta property="og:url" content="http://example.com/2021/02/19/redis-ae/index.html">
<meta property="og:site_name" content="collia&#39;s blog">
<meta property="og:description" content="基于 Redis 6.0.10 通过这篇文章想说明几个问题:  高性能服务器的组成 I&#x2F;O 多路复用的使用 redis 定时器的实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/redis-ae-1.png">
<meta property="article:published_time" content="2021-02-19T10:48:00.000Z">
<meta property="article:modified_time" content="2023-08-12T07:41:20.763Z">
<meta property="article:author" content="collia">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/redis-ae-1.png">


<link rel="canonical" href="http://example.com/2021/02/19/redis-ae/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/02/19/redis-ae/","path":"2021/02/19/redis-ae/","title":"Redis 源码学习 - ae 服务器模块"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis 源码学习 - ae 服务器模块 | collia's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">collia's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1-API-%E5%A3%B0%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">网络服务 API 声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ae-%E6%9C%8D%E5%8A%A1%E5%99%A8-API-%E5%A3%B0%E6%98%8E"><span class="nav-number">2.</span> <span class="nav-text">ae 服务器 API 声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-event-loop"><span class="nav-number">3.1.</span> <span class="nav-text">创建 event_loop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#initServer"><span class="nav-number">3.1.1.</span> <span class="nav-text">initServer()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listenToPort"><span class="nav-number">3.1.2.</span> <span class="nav-text">listenToPort()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6-TCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E4%B8%9A%E5%8A%A1"><span class="nav-number">3.2.</span> <span class="nav-text">接收 TCP 客户端连接业务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#acceptTcpHandler"><span class="nav-number">3.2.1.</span> <span class="nav-text">acceptTcpHandler()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acceptCommonHandler"><span class="nav-number">3.2.2.</span> <span class="nav-text">acceptCommonHandler()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createClient"><span class="nav-number">3.2.3.</span> <span class="nav-text">createClient()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clientAcceptHandler"><span class="nav-number">3.2.4.</span> <span class="nav-text">clientAcceptHandler()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6-TCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%B8%9A%E5%8A%A1"><span class="nav-number">3.3.</span> <span class="nav-text">接收 TCP 客户端数据业务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#connSocketEventHandler"><span class="nav-number">3.3.1.</span> <span class="nav-text">connSocketEventHandler()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readQueryFromClient"><span class="nav-number">3.3.2.</span> <span class="nav-text">readQueryFromClient()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#postponeClientRead"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">postponeClientRead()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#connSocketRead"><span class="nav-number">3.3.3.</span> <span class="nav-text">connSocketRead()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%BB%99-TCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%9A%E5%8A%A1"><span class="nav-number">3.4.</span> <span class="nav-text">发送数据给 TCP 客户端业务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#handleClientsWithPendingWritesUsingThreads"><span class="nav-number">3.4.1.</span> <span class="nav-text">handleClientsWithPendingWritesUsingThreads()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#handleClientsWithPendingWrites"><span class="nav-number">3.4.2.</span> <span class="nav-text">handleClientsWithPendingWrites()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeToClient"><span class="nav-number">3.4.3.</span> <span class="nav-text">writeToClient()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#clientHasPendingReplies"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">clientHasPendingReplies()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sendReplyToClient"><span class="nav-number">3.4.4.</span> <span class="nav-text">sendReplyToClient()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.</span> <span class="nav-text">定时器业务的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.6.</span> <span class="nav-text">命令解析功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#processCommandAndResetClient"><span class="nav-number">3.6.1.</span> <span class="nav-text">processCommandAndResetClient()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%9B%9E%E5%A4%8D%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.7.</span> <span class="nav-text">命令回复功能的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#addReply"><span class="nav-number">3.7.1.</span> <span class="nav-text">addReply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prepareClientToWrite"><span class="nav-number">3.7.2.</span> <span class="nav-text">prepareClientToWrite()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addReplyToBuffer"><span class="nav-number">3.7.3.</span> <span class="nav-text">_addReplyToBuffer()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ae-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E5%88%86-API-%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">ae 服务器部分 API 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-aeEventLoop"><span class="nav-number">4.1.</span> <span class="nav-text">struct aeEventLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-aeFileEvent"><span class="nav-number">4.2.</span> <span class="nav-text">struct aeFileEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-aeFiredEvent"><span class="nav-number">4.3.</span> <span class="nav-text">struct aeFiredEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-aeTimeEvent"><span class="nav-number">4.4.</span> <span class="nav-text">struct aeTimeEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aeCreateEventLoop"><span class="nav-number">4.5.</span> <span class="nav-text">aeCreateEventLoop()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aeApiCreate"><span class="nav-number">4.5.1.</span> <span class="nav-text">aeApiCreate()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aeCreateFileEvent"><span class="nav-number">4.6.</span> <span class="nav-text">aeCreateFileEvent()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aeApiAddEvent"><span class="nav-number">4.6.1.</span> <span class="nav-text">aeApiAddEvent()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aeCreateTimeEvent"><span class="nav-number">4.7.</span> <span class="nav-text">aeCreateTimeEvent()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aeMain"><span class="nav-number">4.8.</span> <span class="nav-text">aeMain()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aeProcessEvents"><span class="nav-number">4.8.1.</span> <span class="nav-text">aeProcessEvents()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aeSearchNearestTimer"><span class="nav-number">4.8.2.</span> <span class="nav-text">aeSearchNearestTimer()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aeApiPoll"><span class="nav-number">4.8.3.</span> <span class="nav-text">aeApiPoll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#processTimeEvents"><span class="nav-number">4.8.4.</span> <span class="nav-text">processTimeEvents()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E9%83%A8%E5%88%86-API-%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">网络服务部分 API 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#anetTcpServer"><span class="nav-number">5.1.</span> <span class="nav-text">anetTcpServer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anetTcp6Server"><span class="nav-number">5.2.</span> <span class="nav-text">anetTcp6Server()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anetTcpServer-1"><span class="nav-number">5.3.</span> <span class="nav-text">_anetTcpServer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anetListen"><span class="nav-number">5.4.</span> <span class="nav-text">anetListen()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anetTcpAccept"><span class="nav-number">5.5.</span> <span class="nav-text">anetTcpAccept()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anetGenericAccept"><span class="nav-number">5.6.</span> <span class="nav-text">anetGenericAccept()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">6.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-client"><span class="nav-number">6.1.</span> <span class="nav-text">struct client</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">collia</p>
  <div class="site-description" itemprop="description">recording</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/19/redis-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="collia">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="collia's blog">
      <meta itemprop="description" content="recording">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis 源码学习 - ae 服务器模块 | collia's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 源码学习 - ae 服务器模块
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-19 18:48:00" itemprop="dateCreated datePublished" datetime="2021-02-19T18:48:00+08:00">2021-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-12 15:41:20" itemprop="dateModified" datetime="2023-08-12T15:41:20+08:00">2023-08-12</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>基于 Redis 6.0.10</p>
<p>通过这篇文章想说明几个问题:</p>
<ul>
<li>高性能服务器的组成</li>
<li>I&#x2F;O 多路复用的使用</li>
<li>redis 定时器的实现</li>
</ul>
<span id="more"></span>

<h2 id="网络服务-API-声明"><a href="#网络服务-API-声明" class="headerlink" title="网络服务 API 声明"></a>网络服务 API 声明</h2><p>网络服务器启动一般需要经过必要的几个流程:</p>
<ul>
<li>通过 bind(), 把网络地址和 socket 绑定;</li>
<li>通过 listen(), 实现网络地址监听;</li>
<li>通过 accept(), 实现对 socket 连接的接管接受;</li>
<li>通过 read()&#x2F;recv(), 接受来自 socket 的数据;</li>
<li>通过 write&#x2F;send(), 发送来自 socket 的数据;</li>
<li>通过 shutdown()和 close(), 关闭 socket 连接.</li>
</ul>
<p>根据源码中搜索, 可以在 <code>anet.c</code> 中看到相关函数的调用, 它的头文件 <code>anet.h</code> 就是 Redis 对这些 socket 操作函数的封装:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接 TCP 服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpConnect</span><span class="params">(<span class="type">char</span> *err, <span class="type">const</span> <span class="type">char</span> *addr, <span class="type">int</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpNonBlockConnect</span><span class="params">(<span class="type">char</span> *err, <span class="type">const</span> <span class="type">char</span> *addr, <span class="type">int</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpNonBlockBindConnect</span><span class="params">(<span class="type">char</span> *err, <span class="type">const</span> <span class="type">char</span> *addr, <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *source_addr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpNonBlockBestEffortBindConnect</span><span class="params">(<span class="type">char</span> *err, <span class="type">const</span> <span class="type">char</span> *addr, <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *source_addr)</span>;</span><br><span class="line"><span class="comment">// unix socket 连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetUnixConnect</span><span class="params">(<span class="type">char</span> *err, <span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetUnixNonBlockConnect</span><span class="params">(<span class="type">char</span> *err, <span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="comment">// read() 封装, 获取传输数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetRead</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="comment">// 对端信息获取</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetResolve</span><span class="params">(<span class="type">char</span> *err, <span class="type">char</span> *host, <span class="type">char</span> *ipbuf, <span class="type">size_t</span> ipbuf_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetResolveIP</span><span class="params">(<span class="type">char</span> *err, <span class="type">char</span> *host, <span class="type">char</span> *ipbuf, <span class="type">size_t</span> ipbuf_len)</span>;</span><br><span class="line"><span class="comment">// 创建 TCP 服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpServer</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> port, <span class="type">char</span> *bindaddr, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// 创建 TCP 服务器(IPv6)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcp6Server</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> port, <span class="type">char</span> *bindaddr, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetUnixServer</span><span class="params">(<span class="type">char</span> *err, <span class="type">char</span> *path, <span class="type">mode_t</span> perm, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// 接收 TCP 客户端的连接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpAccept</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> serversock, <span class="type">char</span> *ip, <span class="type">size_t</span> ip_len, <span class="type">int</span> *port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetUnixAccept</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> serversock)</span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetWrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="comment">// 设置 socket 非阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetNonBlock</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 设置 socket 阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetBlock</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 设置 socket 使用 nagle 算法传输数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetEnableTcpNoDelay</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 设置 socket 不使用 nagle 算法传输数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetDisableTcpNoDelay</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 启用 tcp 保活功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetTcpKeepAlive</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 阻塞发送数据带超时</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetSendTimeout</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> ms)</span>;</span><br><span class="line"><span class="comment">// 阻塞接受数据带超时</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetRecvTimeout</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> ms)</span>;</span><br><span class="line"><span class="comment">// 获取对端连接信息(以字符串形式获取)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">anetPeerToString</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ip, <span class="type">size_t</span> ip_len, <span class="type">int</span> *port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetKeepAlive</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> fd, <span class="type">int</span> interval)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetSockName</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ip, <span class="type">size_t</span> ip_len, <span class="type">int</span> *port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetFormatAddr</span><span class="params">(<span class="type">char</span> *fmt, <span class="type">size_t</span> fmt_len, <span class="type">char</span> *ip, <span class="type">int</span> port)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetFormatPeer</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *fmt, <span class="type">size_t</span> fmt_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">anetFormatSock</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *fmt, <span class="type">size_t</span> fmt_len)</span>;</span><br></pre></td></tr></table></figure>

<p>通过搜索 anet* 相关的函数调用, 就可以知道 Redis 是怎么启动与使用服务器的了.</p>
<p>这样封装的好处是可移植性高. 只要 Redis 内部约定全部只使用这些函数对连接进行操作和管理, 那么这之下就可以对 bind()、listen() 等系统调用进行替换. 比如使用 dpdk 编写自己的用户态协议栈的时候, 从而在不改变外层业务逻辑的前提下大幅提高程序的单机性能.</p>
<h2 id="ae-服务器-API-声明"><a href="#ae-服务器-API-声明" class="headerlink" title="ae 服务器 API 声明"></a>ae 服务器 API 声明</h2><p>根据外层对上述 anet* 相关函数的调用, 可以找到 ae 服务器相关的 API, 在 <code>src/ae.h</code> 中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ae 事件循环</span></span><br><span class="line">aeEventLoop *<span class="title function_">aeCreateEventLoop</span><span class="params">(<span class="type">int</span> setsize)</span>;</span><br><span class="line"><span class="comment">// 删除一个 ae 事件循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span>;</span><br><span class="line"><span class="comment">// 停止一个 ae 事件循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">aeStop</span><span class="params">(aeEventLoop *eventLoop)</span>;</span><br><span class="line"><span class="comment">// 往一个 ae 事件循环中添加文件描述符事件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">        aeFileProc *proc, <span class="type">void</span> *clientData)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> milliseconds,</span></span><br><span class="line"><span class="params">        aeTimeProc *proc, <span class="type">void</span> *clientData,</span></span><br><span class="line"><span class="params">        aeEventFinalizerProc *finalizerProc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aeWait</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> mask, <span class="type">long</span> <span class="type">long</span> milliseconds)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">aeGetApiName</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">aeSetBeforeSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">aeSetAfterSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aeGetSetSize</span><span class="params">(aeEventLoop *eventLoop)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aeResizeSetSize</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> setsize)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">aeSetDontWait</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> noWait)</span>;</span><br></pre></td></tr></table></figure>

<p>往下探究可以发现其实 ae 的实现会根据不同操作系统有不同的实现, 只要保证 ae 服务器对外只使用这些 API 接口, 就能任意替换底下实现 IO 多路复用的基础框架.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面通过源码介绍 Redis 是怎么使用 ae 服务器的.</p>
<h3 id="创建-event-loop"><a href="#创建-event-loop" class="headerlink" title="创建 event_loop"></a>创建 event_loop</h3><p>在 server.c 中 main() 调用了 initServer() 来初始化服务器资源.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 初始化服务器</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">// 初始化服务器收尾, 创建 IO 线程池并让它们等待</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化服务器收尾, 创建 IO 线程池并让它们等待</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行事件循环</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    <span class="comment">// 销毁资源退出程序</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initServer"><a href="#initServer" class="headerlink" title="initServer()"></a>initServer()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 创建 IO 多路复用的事件循环反应器</span></span><br><span class="line">    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">    <span class="keyword">if</span> (server.el == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed creating the event loop. Error message: &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 监听普通地址</span></span><br><span class="line">    <span class="comment">/* Open the TCP listening socket for the user commands. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 监听 tls 地址, 需要 openssl 解密</span></span><br><span class="line">    <span class="keyword">if</span> (server.tls_port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.tls_port,server.tlsfd,&amp;server.tlsfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 创建事件循环的定时器任务</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Can&#x27;t create event loop timers.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">     * domain sockets. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="comment">// 设置事件循环的回调函数, 通过 acceptTcpHandler() 会调用 accept() 接受连接</span></span><br><span class="line">        <span class="comment">// 只监听读事件</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                serverPanic(</span><br><span class="line">                    <span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.tlsfd_count; j++) &#123;</span><br><span class="line">        <span class="comment">// 设置事件循环的回调函数, 通过 acceptTLSHandler() 会调用 accept() 接受连接</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.tlsfd[j], AE_READABLE,</span><br><span class="line">            acceptTLSHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                serverPanic(</span><br><span class="line">                    <span class="string">&quot;Unrecoverable error creating server.tlsfd file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="listenToPort"><a href="#listenToPort" class="headerlink" title="listenToPort()"></a>listenToPort()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listenToPort</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> *fds, <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// server.bindaddr_count 中存储了配置文件和命令行中 bind 配置的地址数量</span></span><br><span class="line">    <span class="comment">// server.bindaddr 中则存储了相应的地址</span></span><br><span class="line">    <span class="comment">// 如果没有配置地址信息, 则默认监听所有地址</span></span><br><span class="line">    <span class="comment">/* Force binding of 0.0.0.0 if no bind address is specified, always</span></span><br><span class="line"><span class="comment">     * entering the loop if j == 0. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.bindaddr_count == <span class="number">0</span>) server.bindaddr[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.bindaddr_count || j == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一般来说只有当没有配置地址时才会进入</span></span><br><span class="line">        <span class="keyword">if</span> (server.bindaddr[j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">int</span> unsupported = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 通常来说, 在这里进行地址绑定与监听 anetTcp6Server() 只支持 IPv6</span></span><br><span class="line">            <span class="comment">/* Bind * for both IPv6 and IPv4, we enter here only if</span></span><br><span class="line"><span class="comment">             * server.bindaddr_count == 0. */</span></span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr,port,<span class="literal">NULL</span>,</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">            <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                <span class="comment">// 给连接用 socket 设置非阻塞</span></span><br><span class="line">                anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">                (*count)++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAFNOSUPPORT) &#123;</span><br><span class="line">                unsupported++;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Not listening to IPv6: unsupported&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 IPv6 绑定成功, 则进行 IPv4 绑定</span></span><br><span class="line">            <span class="comment">// 如果 IPv6 绑定失败, 并且是不支持导致的, 则进行 IPv4 绑定</span></span><br><span class="line">            <span class="comment">// 否则 IPv6 绑定失败且不是因为不支持 IPv6, 就退出</span></span><br><span class="line">            <span class="keyword">if</span> (*count == <span class="number">1</span> || unsupported) &#123;</span><br><span class="line">                <span class="comment">// 监听 IPv4 地址</span></span><br><span class="line">                <span class="comment">/* Bind the IPv4 address as well. */</span></span><br><span class="line">                fds[*count] = anetTcpServer(server.neterr,port,<span class="literal">NULL</span>,</span><br><span class="line">                    server.tcp_backlog);</span><br><span class="line">                <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                    <span class="comment">// 给连接用 socket 设置非阻塞</span></span><br><span class="line">                    anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">                    (*count)++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAFNOSUPPORT) &#123;</span><br><span class="line">                    unsupported++;</span><br><span class="line">                    serverLog(LL_WARNING,<span class="string">&quot;Not listening to IPv4: unsupported&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 绑定成功 退出循环</span></span><br><span class="line">            <span class="comment">/* Exit the loop if we were able to bind * on IPv4 and IPv6,</span></span><br><span class="line"><span class="comment">             * otherwise fds[*count] will be ANET_ERR and we&#x27;ll print an</span></span><br><span class="line"><span class="comment">             * error and return to the caller with an error. */</span></span><br><span class="line">            <span class="keyword">if</span> (*count + unsupported == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// IPv6 地址监听</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(server.bindaddr[j],<span class="string">&#x27;:&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Bind IPv6 address. */</span></span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">        <span class="comment">// IPv4 地址监听</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Bind IPv4 address. */</span></span><br><span class="line">            fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听失败</span></span><br><span class="line">        <span class="keyword">if</span> (fds[*count] == ANET_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Could not create server TCP listening socket %s:%d: %s&quot;</span>,</span><br><span class="line">                server.bindaddr[j] ? server.bindaddr[j] : <span class="string">&quot;*&quot;</span>,</span><br><span class="line">                port, server.neterr);</span><br><span class="line">                <span class="keyword">if</span> (errno == ENOPROTOOPT     || errno == EPROTONOSUPPORT ||</span><br><span class="line">                    errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||</span><br><span class="line">                    errno == EAFNOSUPPORT    || errno == EADDRNOTAVAIL)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对监听配置了具体地址的 socket 设置非阻塞</span></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个很重要的点是会对所有监听的 socket 设置非阻塞, 这样可以方便 Redis 在没有连接事件的时候做定时器任务或其他任务, 而不是让线程白白空闲, 可以减少线程数量降低上下文切换次数从而提高整机性能.</p>
<h3 id="接收-TCP-客户端连接业务"><a href="#接收-TCP-客户端连接业务" class="headerlink" title="接收 TCP 客户端连接业务"></a>接收 TCP 客户端连接业务</h3><p>接下来来看看 Redis 在接受客户端连接时做了什么操作, 即 Redis 的 Accept 业务.</p>
<h4 id="acceptTcpHandler"><a href="#acceptTcpHandler" class="headerlink" title="acceptTcpHandler()"></a>acceptTcpHandler()</h4><p>处理连接事件的回调函数, 通过 aeCreateFileEvent() 被添加到 event_loop 中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="type">char</span> cip[NET_IP_STR_LEN];</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        <span class="comment">// 创建连接用 socket, 返回值对应 sockfd, cip 存储服务端 ip 地址字符串, cport 存储服务端端口</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;Accepting client connection: %s&quot;</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答应服务端使用的 IP 地址与端口</span></span><br><span class="line">        serverLog(LL_VERBOSE,<span class="string">&quot;Accepted %s:%d&quot;</span>, cip, cport);</span><br><span class="line">        <span class="comment">// 调用建立连接完成后的回调函数</span></span><br><span class="line">        <span class="comment">// connCreateAcceptedSocket 会创建 rpc 连接与应用层连接, 并设置连接状态,  rpc 连接使用的回调函数集合为 CT_Socket</span></span><br><span class="line">        acceptCommonHandler(connCreateAcceptedSocket(cfd),<span class="number">0</span>,cip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acceptCommonHandler"><a href="#acceptCommonHandler" class="headerlink" title="acceptCommonHandler()"></a>acceptCommonHandler()</h4><p>Linux 的协议栈层面 TCP 会话已经建立, Redis 应用层面的会话资源也创建好了, 但需要对连接进行详细配置并加入 event_loop 中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ACCEPTS_PER_CALL 1000</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">acceptCommonHandler</span><span class="params">(connection *conn, <span class="type">int</span> flags, <span class="type">char</span> *ip)</span> &#123;</span><br><span class="line">    client *c;</span><br><span class="line">    <span class="type">char</span> conninfo[<span class="number">100</span>];</span><br><span class="line">    UNUSED(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 rpc 连接状态</span></span><br><span class="line">    <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_ACCEPTING) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE,</span><br><span class="line">            <span class="string">&quot;Accepted client connection in error state: %s (conn: %s)&quot;</span>,</span><br><span class="line">            connGetLastError(conn),</span><br><span class="line">            connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">        connClose(conn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数量超限, 给客户端报错同时主动断开 TCP 连接</span></span><br><span class="line">    <span class="comment">/* Limit the number of connections we take at the same time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Admission control will happen before a client is created and connAccept()</span></span><br><span class="line"><span class="comment">     * called, because we don&#x27;t want to even start transport-level negotiation</span></span><br><span class="line"><span class="comment">     * if rejected. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.clients) + getClusterConnectionsCount()</span><br><span class="line">        &gt;= server.maxclients)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *err;</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">            err = <span class="string">&quot;-ERR max number of clients + cluster &quot;</span></span><br><span class="line">                  <span class="string">&quot;connections reached\r\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = <span class="string">&quot;-ERR max number of clients reached\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是调用 connSocketWrite() 回调函数, 直接同步通过 fd 往客户端写数据</span></span><br><span class="line">        <span class="comment">/* That&#x27;s a best effort error message, don&#x27;t check write errors.</span></span><br><span class="line"><span class="comment">         * Note that for TLS connections, no handshake was done yet so nothing</span></span><br><span class="line"><span class="comment">         * is written and the connection will just drop. */</span></span><br><span class="line">        <span class="keyword">if</span> (connWrite(conn,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        server.stat_rejected_conn++;</span><br><span class="line">        <span class="comment">// 这里是调用 connSocketClose() 回调函数, 从 event_loop 中删除连接监听事件, 并直接同步断开连接</span></span><br><span class="line">        connClose(conn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据连接创建客户端资源</span></span><br><span class="line">    <span class="comment">// 把 rpc 连接设置到 client 的 conn 中, 设置应用层读取回调函数, 把客户端资源放入 ae 服务器中</span></span><br><span class="line">    <span class="comment">/* Create connection and client */</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(conn)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Error registering fd event for the new client: %s (conn: %s)&quot;</span>,</span><br><span class="line">            connGetLastError(conn),</span><br><span class="line">            connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">        connClose(conn); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last chance to keep flags */</span></span><br><span class="line">    c-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connAccept() 会调用 connSocketAccept()</span></span><br><span class="line">    <span class="comment">// 实际上就是设置连接状态, 然后通过 callHandler() 调用 clientAcceptHandler()</span></span><br><span class="line">    <span class="comment">// 目的是进行数据库部分功能的业务处理</span></span><br><span class="line">    <span class="comment">/* Initiate accept.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that connAccept() is free to do two things here:</span></span><br><span class="line"><span class="comment">     * 1. Call clientAcceptHandler() immediately;</span></span><br><span class="line"><span class="comment">     * 2. Schedule a future call to clientAcceptHandler().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Because of that, we must do nothing else afterwards.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (connAccept(conn, clientAcceptHandler) == C_ERR) &#123;</span><br><span class="line">        <span class="type">char</span> conninfo[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_ERROR)</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;Error accepting a client connection: %s (conn: %s)&quot;</span>,</span><br><span class="line">                    connGetLastError(conn), connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">        freeClient(connGetPrivateData(conn));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createClient"><a href="#createClient" class="headerlink" title="createClient()"></a>createClient()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">client *<span class="title function_">createClient</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing NULL as conn it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        connEnableTcpNoDelay(conn);</span><br><span class="line">        <span class="comment">// 配置文件中默认为 300s</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 设置连接的回调函数为 readQueryFromClient(), 会被 callHandler() 调用, 用于解析应用层数据</span></span><br><span class="line">        <span class="comment">// 同时设置 event_loop 对该 fd 可读的回调函数为 connSocketEventHandler()</span></span><br><span class="line">        <span class="comment">// 顺便把 fd 的 clientData 指向连接 conn</span></span><br><span class="line">        <span class="comment">// 读取在 redis 中涉及到三个回调函数, 将在下面的接收 TCP 客户端数据业务中进行说明</span></span><br><span class="line">        connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">        <span class="comment">// 把 client 结构当作 data 放进 conn 中</span></span><br><span class="line">        connSetPrivateData(conn, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 把当前 client 插入 server.client 队列中, 尾插法, 并在 clinet-&gt;client_list_node 保存自己的位置</span></span><br><span class="line">    <span class="keyword">if</span> (conn) linkClient(c);</span><br><span class="line">    <span class="comment">// 初始化 multi 状态, 事务状态使用 ??</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clientAcceptHandler"><a href="#clientAcceptHandler" class="headerlink" title="clientAcceptHandler()"></a>clientAcceptHandler()</h4><p>进行数据库部分功能的业务处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clientAcceptHandler</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Error accepting a client connection: %s&quot;</span>,</span><br><span class="line">                connGetLastError(conn));</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the server is running in protected mode (the default) and there</span></span><br><span class="line"><span class="comment">     * is no password set, nor a specific interface is bound, we don&#x27;t accept</span></span><br><span class="line"><span class="comment">     * requests from non loopback interfaces. Instead we try to explain the</span></span><br><span class="line"><span class="comment">     * user what to do to fix it if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.protected_mode &amp;&amp;</span><br><span class="line">        server.bindaddr_count == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_UNIX_SOCKET))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> cip[NET_IP_STR_LEN+<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        connPeerToString(conn, cip, <span class="keyword">sizeof</span>(cip)<span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cip,<span class="string">&quot;127.0.0.1&quot;</span>) &amp;&amp; <span class="built_in">strcmp</span>(cip,<span class="string">&quot;::1&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">char</span> *err =</span><br><span class="line">                <span class="string">&quot;-DENIED Redis is running in protected mode because protected &quot;</span></span><br><span class="line">                <span class="string">&quot;mode is enabled, no bind address was specified, no &quot;</span></span><br><span class="line">                <span class="string">&quot;authentication password is requested to clients. In this mode &quot;</span></span><br><span class="line">                <span class="string">&quot;connections are only accepted from the loopback interface. &quot;</span></span><br><span class="line">                <span class="string">&quot;If you want to connect from external computers to Redis you &quot;</span></span><br><span class="line">                <span class="string">&quot;may adopt one of the following solutions: &quot;</span></span><br><span class="line">                <span class="string">&quot;1) Just disable protected mode sending the command &quot;</span></span><br><span class="line">                <span class="string">&quot;&#x27;CONFIG SET protected-mode no&#x27; from the loopback interface &quot;</span></span><br><span class="line">                <span class="string">&quot;by connecting to Redis from the same host the server is &quot;</span></span><br><span class="line">                <span class="string">&quot;running, however MAKE SURE Redis is not publicly accessible &quot;</span></span><br><span class="line">                <span class="string">&quot;from internet if you do so. Use CONFIG REWRITE to make this &quot;</span></span><br><span class="line">                <span class="string">&quot;change permanent. &quot;</span></span><br><span class="line">                <span class="string">&quot;2) Alternatively you can just disable the protected mode by &quot;</span></span><br><span class="line">                <span class="string">&quot;editing the Redis configuration file, and setting the protected &quot;</span></span><br><span class="line">                <span class="string">&quot;mode option to &#x27;no&#x27;, and then restarting the server. &quot;</span></span><br><span class="line">                <span class="string">&quot;3) If you started the server manually just for testing, restart &quot;</span></span><br><span class="line">                <span class="string">&quot;it with the &#x27;--protected-mode no&#x27; option. &quot;</span></span><br><span class="line">                <span class="string">&quot;4) Setup a bind address or an authentication password. &quot;</span></span><br><span class="line">                <span class="string">&quot;NOTE: You only need to do one of the above things in order for &quot;</span></span><br><span class="line">                <span class="string">&quot;the server to start accepting connections from the outside.\r\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (connWrite(c-&gt;conn,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">            &#125;</span><br><span class="line">            server.stat_rejected_conn++;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.stat_numconnections++;</span><br><span class="line">    <span class="comment">// 数据库部分相关功能抽象成 module 进行处理, 这个函数最重要的部分</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,</span><br><span class="line">                          REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED,</span><br><span class="line">                          c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收-TCP-客户端数据业务"><a href="#接收-TCP-客户端数据业务" class="headerlink" title="接收 TCP 客户端数据业务"></a>接收 TCP 客户端数据业务</h3><p>Redis 在接收数据的时候, 可以看成有三个接收数据用的回调函数, 其中两个在 <code>CT_Socket</code> 中, 分别是 connSocketEventHandler()、connSocketRead(), 还有一个 readQueryFromClient().</p>
<h4 id="connSocketEventHandler"><a href="#connSocketEventHandler" class="headerlink" title="connSocketEventHandler()"></a>connSocketEventHandler()</h4><p>是最外层的接收数据函数, ae 服务器的 event_loop 的收到数据后调用的回调函数.</p>
<p>通过 gdb 调试可以看到:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 &quot;redis-server&quot; hit Breakpoint 4, connSocketEventHandler (el=0x7ffff780b480, fd=8, </span><br><span class="line">    clientData=0x7ffff78150c0, mask=1) at connection.c:261</span><br><span class="line">261	    if (conn-&gt;state == CONN_STATE_CONNECTING &amp;&amp;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  connSocketEventHandler (el=0x7ffff780b480, fd=8, clientData=0x7ffff78150c0, mask=1)</span></span><br><span class="line">    at connection.c:261</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00005555555929f7 <span class="keyword">in</span> aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff780b480,</span> </span><br><span class="line">    flags=flags@entry=27) at ae.c:479</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000555555592d3d <span class="keyword">in</span> aeMain (eventLoop=0x7ffff780b480) at ae.c:539</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x000055555558f536 <span class="keyword">in</span> main (argc=3, argv=0x7fffffffe438) at server.c:5498</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个函数直接由 aeProcessEvents() 去回调的, 我的理解是这一层回调的功能是读取和输出的总控制. 正常情况都是读取客户端数据, 然后解析并计算请求, 然后将结果发送给客户端. 但这个情景是有可能存在特殊情况需要反转的. 翻阅了源码后, 发现 connSetWriteHandlerWithBarrier() 是唯一控制反转的 API, 而只有 clusterSendMessage() 和 handleClientsWithPendingWrites() 这两个函数调用了它, 和 Redis 的同步功能相关的地方才会出现业务反转现象, 具体到 Redis 的同步功能解析时再具体分析.</p>
<p>接着来看实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">connSocketEventHandler</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *clientData, <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(fd);</span><br><span class="line">    <span class="comment">// clientData 是 conn 是在 createClient() 时设置的</span></span><br><span class="line">    connection *conn = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;state == CONN_STATE_CONNECTING &amp;&amp;</span><br><span class="line">            (mask &amp; AE_WRITABLE) &amp;&amp; conn-&gt;conn_handler) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> conn_error = connGetSocketError(conn);</span><br><span class="line">        <span class="keyword">if</span> (conn_error) &#123;</span><br><span class="line">            conn-&gt;last_errno = conn_error;</span><br><span class="line">            conn-&gt;state = CONN_STATE_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn-&gt;state = CONN_STATE_CONNECTED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;write_handler) aeDeleteFileEvent(server.el,conn-&gt;fd,AE_WRITABLE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;conn_handler)) <span class="keyword">return</span>;</span><br><span class="line">        conn-&gt;conn_handler = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要反转, 正常情况是先执行完读取任务再执行写入任务</span></span><br><span class="line">    <span class="comment">// 但在一些特殊情况, 比如同步到磁盘操作的时候, 需要先执行回写操作再执行读取操作</span></span><br><span class="line">    <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">     * event later. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">     * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">     * query.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However if WRITE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">     * asking us to do the reverse: never fire the writable event</span></span><br><span class="line"><span class="comment">     * after the readable. In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">     * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">     * in the beforeSleep() hook, like fsync&#x27;ing a file to disk,</span></span><br><span class="line"><span class="comment">     * before replying to a client. */</span></span><br><span class="line">    <span class="type">int</span> invert = conn-&gt;flags &amp; CONN_FLAG_WRITE_BARRIER;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> call_write = (mask &amp; AE_WRITABLE) &amp;&amp; conn-&gt;write_handler;</span><br><span class="line">    <span class="type">int</span> call_read = (mask &amp; AE_READABLE) &amp;&amp; conn-&gt;read_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行的是 readQueryFromClient()</span></span><br><span class="line">    <span class="comment">/* Handle normal I/O flows */</span></span><br><span class="line">    <span class="keyword">if</span> (!invert &amp;&amp; call_read) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;read_handler)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行的是 ()</span></span><br><span class="line">    <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">    <span class="keyword">if</span> (call_write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;write_handler)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">     * after the writable one. */</span></span><br><span class="line">    <span class="keyword">if</span> (invert &amp;&amp; call_read) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;read_handler)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="readQueryFromClient"><a href="#readQueryFromClient" class="headerlink" title="readQueryFromClient()"></a>readQueryFromClient()</h4><p>是被 connSocketEvenHandler() 调用的 read_handler().</p>
<p>这个是真正用于接收和处理来自客户端数据的函数.</p>
<p>gdb 跟踪结果如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 &quot;redis-server&quot; hit Breakpoint 1, readQueryFromClient (conn=0x7ffff78150c0)</span><br><span class="line">    at networking.c:1995</span><br><span class="line">1995	    client *c = connGetPrivateData(conn);</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  readQueryFromClient (conn=0x7ffff78150c0) at networking.c:1995</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x000055555562b818 <span class="keyword">in</span> callHandler (handler=&lt;optimized out&gt;, conn=0x7ffff78150c0)</span></span><br><span class="line">    at connhelpers.h:79</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  connSocketEventHandler (el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;,</span> </span><br><span class="line">    clientData=0x7ffff78150c0, mask=&lt;optimized out&gt;) at connection.c:296</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00005555555929f7 <span class="keyword">in</span> aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff780b480,</span> </span><br><span class="line">    flags=flags@entry=27) at ae.c:479</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000555555592d3d <span class="keyword">in</span> aeMain (eventLoop=0x7ffff780b480) at ae.c:539</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x000055555558f536 <span class="keyword">in</span> main (argc=3, argv=0x7fffffffe438) at server.c:5498</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来看它的实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readQueryFromClient</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    <span class="type">int</span> nread, readlen;</span><br><span class="line">    <span class="type">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 涉及到了 redis 6.0 才有的新特性, 在开启了 io 子线程的时候, 会把当前 client 加入 pending_client 队列中,</span></span><br><span class="line">    <span class="comment">// 之后通过 handleClientsWithPendingReadsUsingThreads() 来获取 client 并进行子线程分发,</span></span><br><span class="line">    <span class="comment">// 再由子线程在 IOThreadMain() 中去获取 client 并进行读取与处理, 最终还是调用这个函数对数据进行读取与分析处理</span></span><br><span class="line">    <span class="comment">/* Check if we want to read from the client later when exiting from</span></span><br><span class="line"><span class="comment">     * the event loop. This is the case if threaded I/O is enabled. */</span></span><br><span class="line">    <span class="keyword">if</span> (postponeClientRead(c)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update total number of reads on server */</span></span><br><span class="line">    server.stat_total_reads_processed++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多读取 1024*16, 即一次 read 最多读取 16k 的数据</span></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="comment">// 如果遇到事务类型需要读取多次数据</span></span><br><span class="line">    <span class="comment">/* If this is a multi bulk request, and we are processing a bulk reply</span></span><br><span class="line"><span class="comment">     * that is large enough, try to maximize the probability that the query</span></span><br><span class="line"><span class="comment">     * buffer contains exactly the SDS string representing the object, even</span></span><br><span class="line"><span class="comment">     * at the risk of requiring more read(2) calls. This way the function</span></span><br><span class="line"><span class="comment">     * processMultiBulkBuffer() can avoid copying buffers to create the</span></span><br><span class="line"><span class="comment">     * Redis Object representing the argument. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> remaining = (<span class="type">size_t</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that the &#x27;remaining&#x27; variable may be zero in some edge case,</span></span><br><span class="line"><span class="comment">         * for example once we resume a blocked client after CLIENT PAUSE. */</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &gt; <span class="number">0</span> &amp;&amp; remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前用于接收数据的 sds 缓冲区已用掉的大小</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 更新偏移 ?? 偏移干吗用的</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    <span class="comment">// 给接收缓冲器增加空间 ?? 为什么不是 querybuf_peak + readlen</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// connRead() 封装了 connSocketRead(), 就是用 read() 去读取 sockfd</span></span><br><span class="line">    nread = connRead(c-&gt;conn, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            <span class="comment">// nonblock 的 read() 的正常返回, 不过因为用了 event_loop 一般不会调用到这个分支中</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,connGetLastError(c-&gt;conn));</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        <span class="comment">// 遇到主从复制状态的机器, 如果是 master, 把读出来的数据复制到 client-&gt;pending_querybuf 中,</span></span><br><span class="line">        <span class="comment">// 之后通过 replicationFeedSlavesFromMasterStream() 发送给 slave 机器一份, 保证主从一致</span></span><br><span class="line">        <span class="comment">/* Append the query buffer to the pending (not applied) buffer</span></span><br><span class="line"><span class="comment">         * of the master. We&#x27;ll use this buffer later in order to have a</span></span><br><span class="line"><span class="comment">         * copy of the string applied by the last command executed. */</span></span><br><span class="line">        c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span><br><span class="line">                                        c-&gt;querybuf+qblen,nread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;</span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接收到的消息</span></span><br><span class="line">    <span class="comment">/* There is more data in the client input buffer, continue parsing it</span></span><br><span class="line"><span class="comment">     * in case to check if there is a full command to execute. */</span></span><br><span class="line">     processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="postponeClientRead"><a href="#postponeClientRead" class="headerlink" title="postponeClientRead()"></a>postponeClientRead()</h5><p>把 client 加入 clients_pending_read 队列等待后续的回调函数进行分发, 交给各个子线程去处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return 1 if we want to handle the client read later using threaded I/O.</span></span><br><span class="line"><span class="comment"> * This is called by the readable handler of the event loop.</span></span><br><span class="line"><span class="comment"> * As a side effect of calling this function the client is put in the</span></span><br><span class="line"><span class="comment"> * pending read clients and flagged as such. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">postponeClientRead</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_active &amp;&amp;</span><br><span class="line">        server.io_threads_do_reads &amp;&amp;</span><br><span class="line">        !ProcessingEventsWhileBlocked &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_READ;</span><br><span class="line">        listAddNodeHead(server.clients_pending_read,c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="connSocketRead"><a href="#connSocketRead" class="headerlink" title="connSocketRead()"></a>connSocketRead()</h4><p>读取 sockfd, read() 的封装.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">connSocketRead</span><span class="params">(connection *conn, <span class="type">void</span> *buf, <span class="type">size_t</span> buf_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = read(conn-&gt;fd, buf, buf_len);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        conn-&gt;state = CONN_STATE_CLOSED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno != EAGAIN) &#123;</span><br><span class="line">        conn-&gt;last_errno = errno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t overwrite the state of a connection that is not already</span></span><br><span class="line"><span class="comment">         * connected, not to mess with handler callbacks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;state == CONN_STATE_CONNECTED)</span><br><span class="line">            conn-&gt;state = CONN_STATE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送数据给-TCP-客户端业务"><a href="#发送数据给-TCP-客户端业务" class="headerlink" title="发送数据给 TCP 客户端业务"></a>发送数据给 TCP 客户端业务</h3><p>Redis 的数据发送流程也是比较繁琐的, 回调函数就有好几个, 这里主要说下 CT_Socket 中的 write 和 write_handler 的区别.</p>
<p>write 是直接发送数据的方法; 而 write_handler 是特殊情况下发送数据的方法, 它也会调用 write. 特殊情况主要指发送反转时、数据一次无法发送完全时的情况.</p>
<p>Redis 发送数据不是在处理完接收与解析后立即进行的, 而是先会把结果保存到 client-&gt;buf 中或者 client-&gt;reply 中, 在下一次循环时由 beforeSleep() 去处理发送数据.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 &quot;redis-server&quot; hit Breakpoint 7, connSocketWrite (conn=0x7ffff78150c0, </span><br><span class="line">    data=0x7ffff791c960, data_len=5) at connection.c:167</span><br><span class="line">167	static int connSocketWrite(connection *conn, const void *data, size_t data_len) &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  connSocketWrite (conn=0x7ffff78150c0, data=0x7ffff791c960, data_len=5) at connection.c:167</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00005555555a76fd <span class="keyword">in</span> connWrite (data_len=&lt;optimized out&gt;, data=&lt;optimized out&gt;,</span> </span><br><span class="line">    conn=&lt;optimized out&gt;) at connection.h:140</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  writeToClient (c=0x7ffff791c700, handler_installed=0) at networking.c:1379</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00005555555a7946 <span class="keyword">in</span> handleClientsWithPendingWrites () at networking.c:1497</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00005555555ad565 <span class="keyword">in</span> handleClientsWithPendingWritesUsingThreads () at networking.c:3189</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00005555555960b2 <span class="keyword">in</span> beforeSleep (eventLoop=&lt;optimized out&gt;) at server.c:2201</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  beforeSleep (eventLoop=&lt;optimized out&gt;) at server.c:2117</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00005555555928b9 <span class="keyword">in</span> aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff780b480,</span> </span><br><span class="line">    flags=flags@entry=27) at ae.c:443</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  0x0000555555592d3d <span class="keyword">in</span> aeMain (eventLoop=0x7ffff780b480) at ae.c:539</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9  0x000055555558f536 <span class="keyword">in</span> main (argc=3, argv=0x7fffffffe438) at server.c:5498</span></span><br></pre></td></tr></table></figure>

<h4 id="handleClientsWithPendingWritesUsingThreads"><a href="#handleClientsWithPendingWritesUsingThreads" class="headerlink" title="handleClientsWithPendingWritesUsingThreads()"></a>handleClientsWithPendingWritesUsingThreads()</h4><p>beforeSleep() 没啥好康的, handleClientsWithPendingWritesUsingThreads() 才是处理发送数据业务的地方.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">handleClientsWithPendingWritesUsingThreads</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Return ASAP if there are no clients. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 IO 线程较少或者禁止 IO 线程的时候, 直接由主线程进行数据发送</span></span><br><span class="line">    <span class="comment">/* If I/O threads are disabled or we have few clients to serve, don&#x27;t</span></span><br><span class="line"><span class="comment">     * use I/O threads, but thejboring synchronous code. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span> || stopThreadedIOIfNeeded()) &#123;</span><br><span class="line">        <span class="comment">// 把记录在每个 client 中的数据发送出去</span></span><br><span class="line">        <span class="keyword">return</span> handleClientsWithPendingWrites();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start threads if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active) startThreadedIO();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;%d TOTAL WRITE pending clients\n&quot;</span>, processed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Distribute the clients across N different lists. */</span></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="type">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove clients from the list of pending writes since</span></span><br><span class="line"><span class="comment">         * they are going to be closed ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;</span><br><span class="line">            listDelNode(server.clients_pending_write, ln);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Give the start condition to the waiting threads, by setting the</span></span><br><span class="line"><span class="comment">     * start condition atomic var. */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_WRITE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="type">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        io_threads_pending[j] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="comment">/* Also use the main thread to process a slice of clients. */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        writeToClient(c,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all the other threads to end their work. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += io_threads_pending[j];</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tio_debug) <span class="built_in">printf</span>(<span class="string">&quot;I/O WRITE All threads finshed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现数据没发完, 设置 write_handler() 为 sendReplyToClient() 下次再发</span></span><br><span class="line">    <span class="comment">/* Run the list of clients again to install the write handler where</span></span><br><span class="line"><span class="comment">     * needed. */</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Install the write handler if there are pending writes in some</span></span><br><span class="line"><span class="comment">         * of the clients. */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;</span><br><span class="line">                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update processed count on server */</span></span><br><span class="line">    server.stat_io_writes_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handleClientsWithPendingWrites"><a href="#handleClientsWithPendingWrites" class="headerlink" title="handleClientsWithPendingWrites()"></a>handleClientsWithPendingWrites()</h4><p>这个函数会先从全局 server 对象的 clients_pending_write 字段(存储 client 对象的链表)挨个取出有数据要发送的 client 对象, 然后调用 writeToClient() 尝试将 client 中存储的应答数据发出去.</p>
<p>当然, 可能存在一种情况是, 由于网络或者客户端的原因, redis-server 某个客户端的数据发送不出去, 或者只有部分可以发出去(例如, 服务器端给客户端发数据, 客户端的应用层一直不从 TCP 内核缓冲区中取出数据, 这样服务器发送一段时间的数据后, 客户端内核缓冲区满了, 服务器再发数据就会发不出去, 由于 fd 是非阻塞的, 这个时候服务器调用 send() 或者 write() 会直接返回, 返回值是 −1, 错误码是 EAGAIN. 不管哪种情况, 数据这一次发不完, 这个时候就需要监听可写事件了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called just before entering the event loop, in the hope</span></span><br><span class="line"><span class="comment"> * we can just write the replies to the client output buffer without any</span></span><br><span class="line"><span class="comment"> * need to use a syscall in order to install the writable event handler,</span></span><br><span class="line"><span class="comment"> * get it called, and so forth. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">handleClientsWithPendingWrites</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If a client is protected, don&#x27;t do anything,</span></span><br><span class="line"><span class="comment">         * that may trigger write error or recreate handler. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t write to clients that are going to be closed anyway. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="comment">/* Try to write buffers to the client socket. */</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发现数据没有全部发完</span></span><br><span class="line">        <span class="comment">// 通过 connSetWriteHandlerWithBarrier() 注册可写事件</span></span><br><span class="line">        <span class="comment">// 设置到 epoll 中, 标记 AE_WRITABLE</span></span><br><span class="line">        <span class="comment">// 设置回调函数 sendReplyToClient() 去发送数据</span></span><br><span class="line">        <span class="comment">/* If after the synchronous writes above we still have data to</span></span><br><span class="line"><span class="comment">         * output to the client, we need to install the writable handler. */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">            <span class="type">int</span> ae_barrier = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* For the fsync=always policy, we want that a given FD is never</span></span><br><span class="line"><span class="comment">             * served for reading and writing in the same event loop iteration,</span></span><br><span class="line"><span class="comment">             * so that in the middle of receiving the query, and serving it</span></span><br><span class="line"><span class="comment">             * to the client, we&#x27;ll call beforeSleep() that will do the</span></span><br><span class="line"><span class="comment">             * actual fsync of AOF to disk. the write barrier ensures that. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp;</span><br><span class="line">                server.aof_fsync == AOF_FSYNC_ALWAYS)</span><br><span class="line">            &#123;</span><br><span class="line">                ae_barrier = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connSetWriteHandlerWithBarrier(c-&gt;conn, sendReplyToClient, ae_barrier) == C_ERR) &#123;</span><br><span class="line">                freeClientAsync(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>connSocketWrite() 是 write() 的封装, 而 connWrite() 是 connSocketWrite() 的封装. 在业务层面发送数据都是通过 writeToClient() 去发送的.</p>
<h4 id="writeToClient"><a href="#writeToClient" class="headerlink" title="writeToClient()"></a>writeToClient()</h4><p>writeToClient() 先把自己处理的 client 对象的 buf 字段的数据发出去, 如果出错的话则释放这个 client. 如果数据能够全部发完, 发完以后则会移除对应的 fd 上的可写事件(如果添加了); 如果当前 client 设置了 CLIENT_CLOSE_AFTER_REPLY 标志, 则发送完数据立即释放这个 client 对象.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write data in output buffers to client. Return C_OK if the client</span></span><br><span class="line"><span class="comment"> * is still valid after the call, C_ERR if it was freed because of some</span></span><br><span class="line"><span class="comment"> * error.  If handler_installed is set, it will attempt to clear the</span></span><br><span class="line"><span class="comment"> * write event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by threads, but always with handler_installed</span></span><br><span class="line"><span class="comment"> * set to 0. So when handler_installed is set to 0 the function must be</span></span><br><span class="line"><span class="comment"> * thread safe. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeToClient</span><span class="params">(client *c, <span class="type">int</span> handler_installed)</span> &#123;</span><br><span class="line">    <span class="comment">/* Update total number of writes on server */</span></span><br><span class="line">    server.stat_total_writes_processed++;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> objlen;</span><br><span class="line">    clientReplyBlock *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否还有待发送数据</span></span><br><span class="line">    <span class="keyword">while</span>(clientHasPendingReplies(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接发送</span></span><br><span class="line">            nwritten = connWrite(c-&gt;conn,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the buffer was sent, set bufpos to zero to continue with</span></span><br><span class="line"><span class="comment">             * the remainder of the reply. */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)c-&gt;sentlen == c-&gt;bufpos) &#123;</span><br><span class="line">                c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = listNodeValue(listFirst(c-&gt;reply));</span><br><span class="line">            objlen = o-&gt;used;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</span><br><span class="line">                c-&gt;reply_bytes -= o-&gt;size;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nwritten = connWrite(c-&gt;conn, o-&gt;buf + c-&gt;sentlen, objlen - c-&gt;sentlen);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we fully sent the object on head go to the next one */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                c-&gt;reply_bytes -= o-&gt;size;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* If there are no longer objects in the list, we expect</span></span><br><span class="line"><span class="comment">                 * the count of reply bytes to be exactly zero. */</span></span><br><span class="line">                <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span>)</span><br><span class="line">                    serverAssert(c-&gt;reply_bytes == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT</span></span><br><span class="line"><span class="comment">         * bytes, in a single threaded server it&#x27;s a good idea to serve</span></span><br><span class="line"><span class="comment">         * other clients as well, even if a very large request comes from</span></span><br><span class="line"><span class="comment">         * super fast link that is always able to accept data (in real world</span></span><br><span class="line"><span class="comment">         * scenario think about &#x27;KEYS *&#x27; against the loopback interface).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * However if we are over the maxmemory limit we ignore that and</span></span><br><span class="line"><span class="comment">         * just deliver as much data as it is possible to deliver.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Moreover, we also send as much as possible if the client is</span></span><br><span class="line"><span class="comment">         * a slave or a monitor (otherwise, on high-speed traffic, the</span></span><br><span class="line"><span class="comment">         * replication/output buffer will grow indefinitely) */</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp;</span><br><span class="line">            !(c-&gt;flags &amp; CLIENT_SLAVE)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server.stat_net_output_bytes += totwritten;</span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connGetState(c-&gt;conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            nwritten = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE,</span><br><span class="line">                <span class="string">&quot;Error writing to client: %s&quot;</span>, connGetLastError(c-&gt;conn));</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* For clients representing masters we don&#x27;t count sending data</span></span><br><span class="line"><span class="comment">         * as an interaction, since we always send REPLCONF ACK commands</span></span><br><span class="line"><span class="comment">         * that take some time to just fill the socket output buffer.</span></span><br><span class="line"><span class="comment">         * We just rely on data / pings received for timeout detection. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据发送完毕</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) &#123;</span><br><span class="line">        c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数据已经发送完了, handler_installed 代表本次发送的是上次没发送完的数据, 被设置了 write_handler 需要清空回调函数</span></span><br><span class="line">        <span class="comment">/* Note that writeToClient() is called in a threaded way, but</span></span><br><span class="line"><span class="comment">         * adDeleteFileEvent() is not thread safe: however writeToClient()</span></span><br><span class="line"><span class="comment">         * is always called with handler_installed set to 0 from threads</span></span><br><span class="line"><span class="comment">         * so we are fine. */</span></span><br><span class="line">        <span class="keyword">if</span> (handler_installed) connSetWriteHandler(c-&gt;conn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Close connection after entire reply has been sent. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="clientHasPendingReplies"><a href="#clientHasPendingReplies" class="headerlink" title="clientHasPendingReplies()"></a>clientHasPendingReplies()</h5><p>如果 bufpos 没置 0 即代表还有数据没有发送完全.</p>
<p>c-&gt;reply 中存放的都是对象, 如果不是空的代表有数据未发送完.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return true if the specified client has pending reply buffers to write to</span></span><br><span class="line"><span class="comment"> * the socket. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clientHasPendingReplies</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;bufpos || listLength(c-&gt;reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下 redis 的数据发送:</p>
<p>如果有数据要发送给某个 client, 不需要专门注册可写事件等触发可写事件再发送.</p>
<p>通常的做法是在应答数据产生的地方直接发送, 如果是因为对端 TCP 窗口太小引起的发送不完, 则将剩余的数据存储至某个缓冲区并注册监听可写事件, 等下次触发可写事件后再尝试发送, 一直到数据全部发送完毕后移除可写事件.</p>
<p>而 redis-server 数据的发送逻辑与这个稍微有点差别, 就是将数据发送的时机放到了 event_loop 的某个时间点上(这里是在 ProcessEvents 之前), 其他的与上面完全一样.</p>
<p>之所以不注册监听可写事件, 可写事件触发再发送数据, 原因是通常情况下, 网络通信的两端数据一般都是正常收发的, 不会出现某一端由于 TCP 窗口太小而使另外一端发不出去的情况. 如果注册监听可写事件, 那么这个事件会频繁触发, 而触发时不一定有数据需要发送, 这样不仅浪费系统资源, 同时也浪费服务器程序宝贵的 CPU 时间片.</p>
<h4 id="sendReplyToClient"><a href="#sendReplyToClient" class="headerlink" title="sendReplyToClient()"></a>sendReplyToClient()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write event handler. Just send data to the client. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReplyToClient</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line">    writeToClient(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器业务的实现"><a href="#定时器业务的实现" class="headerlink" title="定时器业务的实现"></a>定时器业务的实现</h3><p>Redis 中定时器的用途是用于 Cron 任务.</p>
<p>Redis 的定时器实现比较简单粗暴, 并不会对定时任务按照到期事件进行排序来达到减小遍历的优化, 是每次都会去遍历整个定时器任务链表的. 详细的参考 aeCreateTimeEvent()-&gt;processTimeEvents() 代码解析.</p>
<h3 id="命令解析功能的实现"><a href="#命令解析功能的实现" class="headerlink" title="命令解析功能的实现"></a>命令解析功能的实现</h3><p>这里稍微带一点 redis 客户端与服务器之间 resp 协议解析的功能实现.</p>
<p>client 的结构体中 reqtype 代表当前解析状态机解析类型, argc 代表当前命令数量, argv 存储命令对应结构体对象的地址.</p>
<p>在 readQueryFromClient() 处理的最后一步, 会把数据交给 processInputBuffer() 进行处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called every time, in the client structure &#x27;c&#x27;, there is</span></span><br><span class="line"><span class="comment"> * more query buffer to process, because we read more data from the socket</span></span><br><span class="line"><span class="comment"> * or because a client was blocked and later reactivated, so there could be</span></span><br><span class="line"><span class="comment"> * pending query buffer, already representing a full command, to process. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析不依赖临时 pos, 直接使用 client 内部的 qb_pos 进行</span></span><br><span class="line">    <span class="comment">/* Keep processing while there is something in the input buffer */</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        <span class="comment">/* Return if clients are paused. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; clientsArePaused()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Immediately abort if the client is in the middle of something. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_BLOCKED) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t process more buffers from clients that have already pending</span></span><br><span class="line"><span class="comment">         * commands to execute in c-&gt;argv. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_COMMAND) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t process input from the master while there is a busy script</span></span><br><span class="line"><span class="comment">         * condition on the slave. We want just to accumulate the replication</span></span><br><span class="line"><span class="comment">         * stream (instead of replying -BUSY like we do with other clients) and</span></span><br><span class="line"><span class="comment">         * later resume the processing. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.lua_timedout &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is</span></span><br><span class="line"><span class="comment">         * written to the client. Make sure to not let the reply grow after</span></span><br><span class="line"><span class="comment">         * this flag has been set (i.e. don&#x27;t process more commands).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The same applies for clients we want to terminate ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Determine request type when unknown. */</span></span><br><span class="line">        <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</span><br><span class="line">            <span class="comment">// 判断数据是不是以字符 &quot;*&quot; 开头</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;querybuf[c-&gt;qb_pos] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 解析状态机类型切换成 multibulk 模式</span></span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_MULTIBULK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解析状态机类型切换成 inline 模式</span></span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_INLINE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原命令, 结果存储在 argc 与 argv 中</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="comment">// inline 类型处理调用 processInlineBuffer() 进行</span></span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* If the Gopher mode and we got zero or one argument, process</span></span><br><span class="line"><span class="comment">             * the request in Gopher mode. To avoid data race, Redis won&#x27;t</span></span><br><span class="line"><span class="comment">             * support Gopher if enable io threads to read queries. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.gopher_enabled &amp;&amp; !server.io_threads_do_reads &amp;&amp;</span><br><span class="line">                ((c-&gt;argc == <span class="number">1</span> &amp;&amp; ((<span class="type">char</span>*)(c-&gt;argv[<span class="number">0</span>]-&gt;ptr))[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) ||</span><br><span class="line">                  c-&gt;argc == <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                processGopherRequest(c);</span><br><span class="line">                resetClient(c);</span><br><span class="line">                c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">            <span class="comment">// multibulk 类型处理调用 processMultibulkBuffer() 进行</span></span><br><span class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">&quot;Unknown request type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行还原出来的命令</span></span><br><span class="line">        <span class="comment">/* Multibulk processing could see a &lt;= 0 length. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* If we are in the context of an I/O thread, we can&#x27;t really</span></span><br><span class="line"><span class="comment">             * execute the command here. All we can do is to flag the client</span></span><br><span class="line"><span class="comment">             * as one that needs to process the command. */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PENDING_READ) &#123;</span><br><span class="line">                c-&gt;flags |= CLIENT_PENDING_COMMAND;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We are finally ready to execute the command. */</span></span><br><span class="line">            <span class="keyword">if</span> (processCommandAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">                <span class="comment">/* If the client is no longer valid, we avoid exiting this</span></span><br><span class="line"><span class="comment">                 * loop and trimming the client buffer later. So we return</span></span><br><span class="line"><span class="comment">                 * ASAP in that case. */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trim to pos */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;qb_pos) &#123;</span><br><span class="line">        sdsrange(c-&gt;querybuf,c-&gt;qb_pos,<span class="number">-1</span>);</span><br><span class="line">        c-&gt;qb_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还原出来的命令通过 processCommandAndResetClient() 进行执行.</p>
<h4 id="processCommandAndResetClient"><a href="#processCommandAndResetClient" class="headerlink" title="processCommandAndResetClient()"></a>processCommandAndResetClient()</h4><p>实际是由 processCommand() 来执行命令, commandProcessed() 来还原状态机.</p>
<p>processCommand() 流程大致如下:</p>
<ul>
<li><p>先判断是不是 quit 命令, 如果是, 则往发送缓冲区中添加一条应答命令(应答 redis 客户端), 并给当前 client 对象设置 CLIENT_CLOSE_AFTER_REPLY 标志, 即应答完毕后关闭连接;</p>
</li>
<li><p>如果不是 quit 命令, 则使用 lookupCommand() 从全局命令字典表中查找相应的命令, 如果出错, 则向发送缓冲区中添加出错应答, 出错不是指程序逻辑出错, 有可能是客户端发送的非法命令; 如果找到相应的命令, 则执行命令后添加应答.</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function calls processCommand(), but also performs a few sub tasks</span></span><br><span class="line"><span class="comment"> * for the client that are useful in that context:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. It sets the current client to the client &#x27;c&#x27;.</span></span><br><span class="line"><span class="comment"> * 2. calls commandProcessed() if the command was handled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns C_ERR in case the client was freed as a side effect</span></span><br><span class="line"><span class="comment"> * of processing the command, otherwise C_OK is returned. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processCommandAndResetClient</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> deadclient = <span class="number">0</span>;</span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="keyword">if</span> (processCommand(c) == C_OK) &#123;</span><br><span class="line">        commandProcessed(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) deadclient = <span class="number">1</span>;</span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may</span></span><br><span class="line"><span class="comment">     * result into a slave, that may be the active client, to be</span></span><br><span class="line"><span class="comment">     * freed. */</span></span><br><span class="line">    <span class="keyword">return</span> deadclient ? C_ERR : C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令回复功能的实现"><a href="#命令回复功能的实现" class="headerlink" title="命令回复功能的实现"></a>命令回复功能的实现</h3><p>有了命令解析, 也稍微讲讲命令回复功能的实现.</p>
<p>根据前面命令解析的部分, 应该也可以发现, 实际是通过 addReply*() 来实现的.</p>
<p>以 addReply() 来当样本.</p>
<h4 id="addReply"><a href="#addReply" class="headerlink" title="addReply()"></a>addReply()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the object &#x27;obj&#x27; string representation to the client output buffer. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReply</span><span class="params">(client *c, robj *obj)</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="comment">/* For integer encoded strings we just convert it into a string</span></span><br><span class="line"><span class="comment">         * using our optimized function, and attach the resulting string</span></span><br><span class="line"><span class="comment">         * to the output buffer. */</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="type">size_t</span> len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="type">long</span>)obj-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,buf,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addReply() 类函数有两个关键的地方, 一个是 prepareClientToWrite(), 还一个 _addReplyToBuffer().</p>
<h4 id="prepareClientToWrite"><a href="#prepareClientToWrite" class="headerlink" title="prepareClientToWrite()"></a>prepareClientToWrite()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">prepareClientToWrite</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// clientHasPendingReplies() 判断发送缓冲区中是否还有未发送的应答命令</span></span><br><span class="line">    <span class="comment">// 通过 client-&gt;bufpos(int)和 client-&gt;reply(链表)的长度是否大于 0 判断</span></span><br><span class="line">    <span class="comment">/* Schedule the client to write the output buffers to the socket, unless</span></span><br><span class="line"><span class="comment">     * it should already be setup to do so (it has already pending data).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If CLIENT_PENDING_READ is set, we&#x27;re in an IO thread and should</span></span><br><span class="line"><span class="comment">     * not install a write handler. Instead, it will be done by</span></span><br><span class="line"><span class="comment">     * handleClientsWithPendingReadsUsingThreads() upon return.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c) &amp;&amp; !(c-&gt;flags &amp; CLIENT_PENDING_READ))</span><br><span class="line">            <span class="comment">// 设置 CLIENT_PENDING_WRITE 标志, 并将当前 client 添加到 server-&gt;clients_pending_write 链表中</span></span><br><span class="line">            clientInstallWriteHandler(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Authorize the caller to queue in the output buffer of this client. */</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CLIENT_PENDING_WRITE 在 Redis 中代表一个有数据需要发送, 但是还没有注册可写事件的 client 对象.</p>
<h4 id="addReplyToBuffer"><a href="#addReplyToBuffer" class="headerlink" title="_addReplyToBuffer()"></a>_addReplyToBuffer()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Attempts to add the reply to the static buffer in the client struct.</span></span><br><span class="line"><span class="comment"> * Returns C_ERR if the buffer is full, or the reply list is not empty,</span></span><br><span class="line"><span class="comment"> * in which case the reply must be added to the reply list. */</span></span><br><span class="line"><span class="type">int</span> _addReplyToBuffer(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len) &#123;</span><br><span class="line">    <span class="type">size_t</span> available = <span class="keyword">sizeof</span>(c-&gt;buf)-c-&gt;bufpos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断发送缓冲区中是否还有未发送的应答命令</span></span><br><span class="line">    <span class="comment">/* If there already are entries in the reply list, we cannot</span></span><br><span class="line"><span class="comment">     * add anything more to the static buffer. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) &gt; <span class="number">0</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the buffer has enough space available for this string. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; available) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf+c-&gt;bufpos,s,len);</span><br><span class="line">    c-&gt;bufpos+=len;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client-&gt;reply 链表存储的是待发送的应答命令, client-&gt;buf 存储应答命令, 其长度被记录在 client-&gt;bufpos 字段中, client-&gt;buf 是一个固定大小的字节数组, 大小为 PROTO_REPLY_CHUNK_BYTES &#x3D; 16*1024.</p>
<p>写入 reply 与 buf 后, 把 client 加入 server-&gt;clients_pending_write, 接下来就等下次循环进行待发送任务处理了.</p>
<p><img src="/redis-ae-1.png" alt="流程图"></p>
<h2 id="ae-服务器部分-API-实现"><a href="#ae-服务器部分-API-实现" class="headerlink" title="ae 服务器部分 API 实现"></a>ae 服务器部分 API 实现</h2><h3 id="struct-aeEventLoop"><a href="#struct-aeEventLoop" class="headerlink" title="struct aeEventLoop"></a>struct aeEventLoop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* State of an event based program */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前注册进该 event_loop 中最大的文件描述符</span></span><br><span class="line">    <span class="type">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line">    <span class="type">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> timeEventNextId;</span><br><span class="line">    <span class="type">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="type">int</span> stop;</span><br><span class="line">    <span class="type">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">    aeBeforeSleepProc *aftersleep;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>

<h3 id="struct-aeFileEvent"><a href="#struct-aeFileEvent" class="headerlink" title="struct aeFileEvent"></a>struct aeFileEvent</h3><p>普通任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line">    <span class="comment">// 读事件回调函数</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    <span class="comment">// 写事件回调函数</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>

<h3 id="struct-aeFiredEvent"><a href="#struct-aeFiredEvent" class="headerlink" title="struct aeFiredEvent"></a>struct aeFiredEvent</h3><p>过期任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A fired event */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure>

<h3 id="struct-aeTimeEvent"><a href="#struct-aeTimeEvent" class="headerlink" title="struct aeTimeEvent"></a>struct aeTimeEvent</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Time event structure */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> refcount; <span class="comment">/* refcount to prevent timer events from being</span></span><br><span class="line"><span class="comment">  		   * freed in recursive time event calls. */</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure>

<h3 id="aeCreateEventLoop"><a href="#aeCreateEventLoop" class="headerlink" title="aeCreateEventLoop()"></a>aeCreateEventLoop()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setsize 说明当前 event_poll 最多支持监听的事件数量</span></span><br><span class="line"><span class="comment">// setsize 大小默认为 10000(配置文件中的 maxclients) + 128(CONFIG_FDSET_INCR) = 10128</span></span><br><span class="line">aeEventLoop *<span class="title function_">aeCreateEventLoop</span><span class="params">(<span class="type">int</span> setsize)</span> &#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 预分配任务的内存空间</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据不同的操作系统有不同的实现, 底下是不同的 IO 复用框架</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let&#x27;s initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aeApiCreate"><a href="#aeApiCreate" class="headerlink" title="aeApiCreate()"></a>aeApiCreate()</h4><p>创建一个 IO 多路复用的结构.</p>
<p>以 epoll 来举例, 源文件在 <code>src/ae_epoll.c</code> 中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放不同 IO 多路复用用到的资源, 不会对外暴露</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aeCreateFileEvent"><a href="#aeCreateFileEvent" class="headerlink" title="aeCreateFileEvent()"></a>aeCreateFileEvent()</h3><p>往 event_loop 中添加一个文件描述符监听事件.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">        aeFileProc *proc, <span class="type">void</span> *clientData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查文件描述符是否大小异常</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存进用户态的事件队列中</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 IO 多路复用组建中添加监控事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    <span class="comment">// 设置 ae 自己的事件队列项状态</span></span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="comment">// 设置回调函数 ?? 这里感觉可以用个 else 提供性能</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aeApiAddEvent"><a href="#aeApiAddEvent" class="headerlink" title="aeApiAddEvent()"></a>aeApiAddEvent()</h4><p>把一个监听事件从用户态添加到 IO 多路复用组件中.</p>
<p>以 epoll 来举例, 源文件在 <code>src/ae_epoll.c</code> 中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">// 自动判断是修改还是增加事件</span></span><br><span class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></span><br><span class="line"><span class="comment">     * operation. Otherwise we need an ADD operation. */</span></span><br><span class="line">    <span class="type">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 得到 ae 自己的任务标志</span></span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="comment">// 设置对应的 epoll 的任务标志</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// 往 epoll 中添加或删除任务</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aeCreateTimeEvent"><a href="#aeCreateTimeEvent" class="headerlink" title="aeCreateTimeEvent()"></a>aeCreateTimeEvent()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// milliseconds 代表几秒之后进行任务</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> milliseconds,</span></span><br><span class="line"><span class="params">        aeTimeProc *proc, <span class="type">void</span> *clientData,</span></span><br><span class="line"><span class="params">        aeEventFinalizerProc *finalizerProc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id = eventLoop-&gt;timeEventNextId++;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line"></span><br><span class="line">    te = zmalloc(<span class="keyword">sizeof</span>(*te));</span><br><span class="line">    <span class="keyword">if</span> (te == <span class="literal">NULL</span>) <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    te-&gt;id = id;</span><br><span class="line">    <span class="comment">// 计算绝对到期事件并保存到 aeTimeEvent 中</span></span><br><span class="line">    aeAddMillisecondsToNow(milliseconds,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">    te-&gt;timeProc = proc;</span><br><span class="line">    te-&gt;finalizerProc = finalizerProc;</span><br><span class="line">    te-&gt;clientData = clientData;</span><br><span class="line">    <span class="comment">// 双向链表 头插法</span></span><br><span class="line">    te-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    te-&gt;next = eventLoop-&gt;timeEventHead;</span><br><span class="line">    te-&gt;refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">        te-&gt;next-&gt;prev = te;</span><br><span class="line">    eventLoop-&gt;timeEventHead = te;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aeMain"><a href="#aeMain" class="headerlink" title="aeMain()"></a>aeMain()</h3><p>死循环, 每次循环处理 n 次事件.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP|</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aeProcessEvents"><a href="#aeProcessEvents" class="headerlink" title="aeProcessEvents()"></a>aeProcessEvents()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process every pending time event, then every pending file event</span></span><br><span class="line"><span class="comment"> * (that may be registered by time event callbacks just processed).</span></span><br><span class="line"><span class="comment"> * Without special flags the function sleeps until some file event</span></span><br><span class="line"><span class="comment"> * fires, or when the next time event occurs (if any).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If flags is 0, the function does nothing and returns.</span></span><br><span class="line"><span class="comment"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</span></span><br><span class="line"><span class="comment"> * if flags has AE_FILE_EVENTS set, file events are processed.</span></span><br><span class="line"><span class="comment"> * if flags has AE_TIME_EVENTS set, time events are processed.</span></span><br><span class="line"><span class="comment"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</span></span><br><span class="line"><span class="comment"> * the events that&#x27;s possible to process without to wait are processed.</span></span><br><span class="line"><span class="comment"> * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called.</span></span><br><span class="line"><span class="comment"> * if flags has AE_CALL_BEFORE_SLEEP set, the beforesleep callback is called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the number of events processed. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire. */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            <span class="comment">// 搜索最早的定时器任务</span></span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="comment">// 格式化时间戳格式, 组成的 tvp 用于后面判断是否要阻塞等待</span></span><br><span class="line">            <span class="type">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* How many milliseconds we need to wait for the next</span></span><br><span class="line"><span class="comment">             * time event to fire? */</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ms =</span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call the multiplexing API, will return only on timeout or when</span></span><br><span class="line"><span class="comment">         * some event fires. */</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* After sleep callback. */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历处理当前所有已触发事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 通过激活事件的 fd 找到用户态事件存储队列中相应的事件, 其中包含了回调函数</span></span><br><span class="line">            <span class="comment">// ?? 直接去除 fired 队列直接使用 event 指针回传不好吗</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">             * event later. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">             * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">             * query.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * However if AE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">             * asking us to do the reverse: never fire the writable event</span></span><br><span class="line"><span class="comment">             * after the readable. In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">             * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">             * in the beforeSleep() hook, like fsyncing a file to disk,</span></span><br><span class="line"><span class="comment">             * before replying to a client. */</span></span><br><span class="line">            <span class="type">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note the &quot;fe-&gt;mask &amp; mask &amp; ...&quot; code: maybe an already</span></span><br><span class="line"><span class="comment">             * processed event removed an element that fired and we still</span></span><br><span class="line"><span class="comment">             * didn&#x27;t processed, so we check if the event is still valid.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Fire the readable event if the call sequence is not</span></span><br><span class="line"><span class="comment">             * inverted. */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one. */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc))</span><br><span class="line">                &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理到期的定时器任务</span></span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aeSearchNearestTimer"><a href="#aeSearchNearestTimer" class="headerlink" title="aeSearchNearestTimer()"></a>aeSearchNearestTimer()</h4><p>通过绝对时间获取最近的一个的定时器任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Search the first timer to fire.</span></span><br><span class="line"><span class="comment"> * This operation is useful to know how many time the select can be</span></span><br><span class="line"><span class="comment"> * put in sleep without to delay any event.</span></span><br><span class="line"><span class="comment"> * If there are no timers NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that&#x27;s O(N) since time events are unsorted.</span></span><br><span class="line"><span class="comment"> * Possible optimizations (not needed by Redis so far, but...):</span></span><br><span class="line"><span class="comment"> * 1) Insert the event in order, so that the nearest is just the head.</span></span><br><span class="line"><span class="comment"> *    Much better but still insertion or deletion of timers is O(N).</span></span><br><span class="line"><span class="comment"> * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> aeTimeEvent *<span class="title function_">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span><br><span class="line">&#123;</span><br><span class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    aeTimeEvent *nearest = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</span><br><span class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</span><br><span class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</span><br><span class="line">            nearest = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nearest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aeApiPoll"><a href="#aeApiPoll" class="headerlink" title="aeApiPoll()"></a>aeApiPoll()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="type">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="comment">// 把所有激活事件放入 fired 队列中</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> =</span> state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE;</span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processTimeEvents"><a href="#processTimeEvents" class="headerlink" title="processTimeEvents()"></a>processTimeEvents()</h4><p>处理定时器任务.</p>
<p>到期定时任务的处理顺序是类似栈的倒序, 因为定时器任务双向链表是头插法.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process time events */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxId;</span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前计算机的时间被向未来调整过, 那么就强制执行一遍全部的定时任务, 方法是全部设置已到期</span></span><br><span class="line">    <span class="comment">/* If the system clock is moved to the future, and then set back to the</span></span><br><span class="line"><span class="comment">     * right value, time events may be delayed in a random way. Often this</span></span><br><span class="line"><span class="comment">     * means that scheduled operations will not be performed soon enough.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we try to detect system clock skews, and force all the time</span></span><br><span class="line"><span class="comment">     * events to be processed ASAP when this happens: the idea is that</span></span><br><span class="line"><span class="comment">     * processing events earlier is less dangerous than delaying them</span></span><br><span class="line"><span class="comment">     * indefinitely, and practice suggests it is. */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 遍历每一个定时任务</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="type">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove events scheduled for deletion. */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="comment">/* If a reference exists for this timer event,</span></span><br><span class="line"><span class="comment">             * don&#x27;t free it. This is currently incremented</span></span><br><span class="line"><span class="comment">             * for recursive timerProc calls */</span></span><br><span class="line">            <span class="keyword">if</span> (te-&gt;refcount) &#123;</span><br><span class="line">                te = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前没啥用的防御性代码</span></span><br><span class="line">        <span class="comment">/* Make sure we don&#x27;t process time events created by time events in</span></span><br><span class="line"><span class="comment">         * this iteration. Note that this check is currently useless: we always</span></span><br><span class="line"><span class="comment">         * add new timers on the head, however if we change the implementation</span></span><br><span class="line"><span class="comment">         * detail, this check may be useful again: we keep it here for future</span></span><br><span class="line"><span class="comment">         * defense. */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否过期, 过期就执行</span></span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            te-&gt;refcount++;</span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            te-&gt;refcount--;</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络服务部分-API-实现"><a href="#网络服务部分-API-实现" class="headerlink" title="网络服务部分 API 实现"></a>网络服务部分 API 实现</h2><h3 id="anetTcpServer"><a href="#anetTcpServer" class="headerlink" title="anetTcpServer()"></a>anetTcpServer()</h3><p>创建 IPv4 监听 socket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">anetTcpServer</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> port, <span class="type">char</span> *bindaddr, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _anetTcpServer(err, port, bindaddr, AF_INET, backlog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anetTcp6Server"><a href="#anetTcp6Server" class="headerlink" title="anetTcp6Server()"></a>anetTcp6Server()</h3><p>创建 IPv6 监听 socket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">anetTcp6Server</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> port, <span class="type">char</span> *bindaddr, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anetTcpServer-1"><a href="#anetTcpServer-1" class="headerlink" title="_anetTcpServer()"></a>_anetTcpServer()</h3><p>根据配置中的 IP 和端口生成 socket 并监听</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _anetTcpServer(<span class="type">char</span> *err, <span class="type">int</span> port, <span class="type">char</span> *bindaddr, <span class="type">int</span> af, <span class="type">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">-1</span>, rv;</span><br><span class="line">    <span class="type">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen(&quot;65535&quot;) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">&quot;%d&quot;</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    <span class="comment">// 设置 hints </span></span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* No effect if bindaddr != NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 bindaddr 外面设置的是 NULL, 则会根据网卡配置获取真实可用的地址信息</span></span><br><span class="line">    <span class="comment">// 因为 hint 的存在, af = AF_INET 只会得到 IPv4 地址, af = AF_INET6 只会得到 IPv6 地址</span></span><br><span class="line">    <span class="comment">// 如果 bindaddr 设置了具体地址, 则只会得到该地址的信息</span></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr,_port,&amp;hints,&amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;%s&quot;</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">// 根据地址信息创建监听 socket</span></span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 IPv6 地址不兼容 IPv4 地址</span></span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// 设置地址 time_wait 时可重用</span></span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="comment">// 监听 socket</span></span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;unable to bind socket, errno: %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">-1</span>) close(s);</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 释放地址信息, 此内存块为系统申请, 需要通过 freeaddrinfo 释放, 否则造成内存泄漏</span></span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anetListen"><a href="#anetListen" class="headerlink" title="anetListen()"></a>anetListen()</h3><p>绑定加监听</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">anetListen</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> len, <span class="type">int</span> backlog)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(s,sa,len) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;bind: %s&quot;</span>, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(s, backlog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;listen: %s&quot;</span>, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anetTcpAccept"><a href="#anetTcpAccept" class="headerlink" title="anetTcpAccept()"></a>anetTcpAccept()</h3><p>接受连接, 并获取连接信息.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">anetTcpAccept</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> s, <span class="type">char</span> *ip, <span class="type">size_t</span> ip_len, <span class="type">int</span> *port)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> salen = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">    <span class="keyword">if</span> ((fd = anetGenericAccept(err,s,(<span class="keyword">struct</span> sockaddr*)&amp;sa,&amp;salen)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sa.ss_family == AF_INET) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)&amp;sa;</span><br><span class="line">        <span class="keyword">if</span> (ip) inet_ntop(AF_INET,(<span class="type">void</span>*)&amp;(s-&gt;sin_addr),ip,ip_len);</span><br><span class="line">        <span class="keyword">if</span> (port) *port = ntohs(s-&gt;sin_port);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr_in6 *s = (<span class="keyword">struct</span> sockaddr_in6 *)&amp;sa;</span><br><span class="line">        <span class="keyword">if</span> (ip) inet_ntop(AF_INET6,(<span class="type">void</span>*)&amp;(s-&gt;sin6_addr),ip,ip_len);</span><br><span class="line">        <span class="keyword">if</span> (port) *port = ntohs(s-&gt;sin6_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="anetGenericAccept"><a href="#anetGenericAccept" class="headerlink" title="anetGenericAccept()"></a>anetGenericAccept()</h3><p>接受连接.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">anetGenericAccept</span><span class="params">(<span class="type">char</span> *err, <span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        fd = accept(s,sa,len);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                anetSetError(err, <span class="string">&quot;accept: %s&quot;</span>, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="struct-client"><a href="#struct-client" class="headerlink" title="struct client"></a>struct client</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="type">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="type">size_t</span> qb_pos;          <span class="comment">/* The position we have read in querybuf. */</span></span><br><span class="line">    sds pending_querybuf;   <span class="comment">/* If this client is flagged as master, this buffer</span></span><br><span class="line"><span class="comment">                               represents the yet not applied portion of the</span></span><br><span class="line"><span class="comment">                               replication stream that we are receiving from</span></span><br><span class="line"><span class="comment">                               the master. */</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size. */</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="type">size_t</span> argv_len_sum;    <span class="comment">/* Sum of lengths of objects in argv list. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    user *user;             <span class="comment">/* User associated with this connection. If the</span></span><br><span class="line"><span class="comment">                               user is set to NULL the connection can do</span></span><br><span class="line"><span class="comment">                               anything (admin). */</span></span><br><span class="line">    <span class="type">int</span> reqtype;            <span class="comment">/* Request protocol type: PROTO_REQ_* */</span></span><br><span class="line">    <span class="type">int</span> multibulklen;       <span class="comment">/* Number of multi bulk arguments left to read. */</span></span><br><span class="line">    <span class="type">long</span> bulklen;           <span class="comment">/* Length of bulk argument in multi bulk request. */</span></span><br><span class="line">    <span class="built_in">list</span> *reply;            <span class="comment">/* List of reply objects to send to the client. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list. */</span></span><br><span class="line">    <span class="type">size_t</span> sentlen;         <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">/* Client creation time. */</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">/* Time of the last interaction, used for timeout */</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="type">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">    <span class="type">int</span> authenticated;      <span class="comment">/* Needed when the default user requires auth. */</span></span><br><span class="line">    <span class="type">int</span> replstate;          <span class="comment">/* Replication state if this is a slave. */</span></span><br><span class="line">    <span class="type">int</span> repl_put_online_on_ack; <span class="comment">/* Install slave write handler on first ACK. */</span></span><br><span class="line">    <span class="type">int</span> repldbfd;           <span class="comment">/* Replication DB file descriptor. */</span></span><br><span class="line">    <span class="type">off_t</span> repldboff;        <span class="comment">/* Replication DB file offset. */</span></span><br><span class="line">    <span class="type">off_t</span> repldbsize;       <span class="comment">/* Replication DB file size. */</span></span><br><span class="line">    sds replpreamble;       <span class="comment">/* Replication DB preamble. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> read_reploff; <span class="comment">/* Read replication offset if this is a master. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> reploff;      <span class="comment">/* Applied replication offset if this is a master. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_off; <span class="comment">/* Replication ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_time;<span class="comment">/* Replication ack time, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> psync_initial_offset; <span class="comment">/* FULLRESYNC reply offset other slaves</span></span><br><span class="line"><span class="comment">                                       copying this slave output buffer</span></span><br><span class="line"><span class="comment">                                       should use. */</span></span><br><span class="line">    <span class="type">char</span> replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* Master replication ID (if master). */</span></span><br><span class="line">    <span class="type">int</span> slave_listening_port; <span class="comment">/* As configured with: REPLCONF listening-port */</span></span><br><span class="line">    <span class="type">char</span> slave_ip[NET_IP_STR_LEN]; <span class="comment">/* Optionally given by REPLCONF ip-address */</span></span><br><span class="line">    <span class="type">int</span> slave_capa;         <span class="comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    <span class="type">int</span> btype;              <span class="comment">/* Type of blocking op if CLIENT_BLOCKED. */</span></span><br><span class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line">    listNode *client_list_node; <span class="comment">/* list node in client list */</span></span><br><span class="line">    RedisModuleUserChangedFunc auth_callback; <span class="comment">/* Module callback to execute</span></span><br><span class="line"><span class="comment">                                               * when the authenticated user</span></span><br><span class="line"><span class="comment">                                               * changes. */</span></span><br><span class="line">    <span class="type">void</span> *auth_callback_privdata; <span class="comment">/* Private data that is passed when the auth</span></span><br><span class="line"><span class="comment">                                   * changed callback is executed. Opaque for</span></span><br><span class="line"><span class="comment">                                   * Redis Core. */</span></span><br><span class="line">    <span class="type">void</span> *auth_module;      <span class="comment">/* The module that owns the callback, which is used</span></span><br><span class="line"><span class="comment">                             * to disconnect the client if the module is</span></span><br><span class="line"><span class="comment">                             * unloaded for cleanup. Opaque for Redis Core.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this client is in tracking mode and this field is non zero,</span></span><br><span class="line"><span class="comment">     * invalidation messages for keys fetched by this client will be send to</span></span><br><span class="line"><span class="comment">     * the specified client ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> client_tracking_redirection;</span><br><span class="line">    rax *client_tracking_prefixes; <span class="comment">/* A dictionary of prefixes we are already</span></span><br><span class="line"><span class="comment">                                      subscribed to in BCAST mode, in the</span></span><br><span class="line"><span class="comment">                                      context of client side caching. */</span></span><br><span class="line">    <span class="comment">/* In clientsCronTrackClientsMemUsage() we track the memory usage of</span></span><br><span class="line"><span class="comment">     * each client and add it to the sum of all the clients of a given type,</span></span><br><span class="line"><span class="comment">     * however we need to remember what was the old contribution of each</span></span><br><span class="line"><span class="comment">     * client, and in which categoty the client was, in order to remove it</span></span><br><span class="line"><span class="comment">     * before adding it the new value. */</span></span><br><span class="line">    <span class="type">uint64_t</span> client_cron_last_memory_usage;</span><br><span class="line">    <span class="type">int</span>      client_cron_last_memory_type;</span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    <span class="type">char</span> buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/20/lg_gram_2019-battery-limit-with-linux/" rel="prev" title="控制 LG Gram 2019 版在 Linux 下的充电程度">
                  <i class="fa fa-angle-left"></i> 控制 LG Gram 2019 版在 Linux 下的充电程度
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/12/wechat-to-telegram/" rel="next" title="通过 telegram 收发微信信息">
                  通过 telegram 收发微信信息 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">collia</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
